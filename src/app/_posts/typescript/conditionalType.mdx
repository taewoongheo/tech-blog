---
title: '타입스크립트의 조건부 타입'
tags: ['Typescript', 'Javascript']
date: 2024.09.10
description: 타입스크립트의 조건부 타입
thumnail: ''
---

## Introduction

> 타입스크립트의 조건부 타입

## Conditional Type

타입을 조건부로 만드는 것을 conditional type 이라고 한다.

```ts
// T extends U ? X : Y

// 제네릭이 string이면 문자열배열, 아니면 넘버배열
type IsStringType<T> = T extends string ? string[] : number[];

type T1 = IsStringType<string>; // type T1 = string[]
type T2 = IsStringType<number>; // type T2 = number[]

const a: T1 = ['홍길동', '임꺾정', '박혁거세'];
const b: T2 = [1000, 2000, 3000];
```

## distribute conditional type

분산 조건부 타입이란, <> 에 유니온 타입 사용 시, 타입 검사가 `|` 를 기준으로 타입 하나마다 여러 번 검사가 이루어지는 것을 말한다.

```ts
type IsStringType<T> = T extends string ? 'yes' : 'no';

type T1 = IsStringType<string | number>; //T1 = 'yes' | 'no'
```

위 검사에서 T1 의 타입검사를 인스턴스화 하면, `string extends string ? 'yes' : 'no'` 와 `number extends string ? 'yes' : 'no'` 로 각각 두 번 실행된다.

하지만 만약 `(naked) type parameter` 가 아닐 시, 분산이 일어나지 않는다.

- (naked) type parameter는 제네릭 T 와 같이 의미가 없는 타입 파라미터를 말하는 것이며,  
  만일 직접 리터럴 타입을 명시하거나 혹은 제네릭 T\[] 와 같이 변횐된 타입 파라미터이면, naked 가 아니게 된다.

```ts
type T3 = string | number extends string ? 'yes' : 'no';
//T3 = 'no'

type T4 = Array<string | number>;
//T4 = Array<string | number>
```

T3 의 경우 분산이 일어나지 않는다. 따라서 `string | number` 타입이 `string` 에 포함되는 지 검사한다. 포함되지 않으므로, 'no'

```ts
type T1 = 1 | 3 | 5 | 7 extends number ? 'yes' : 'no'; // naked 타입이 아니라서 분산이 되지 않는다.
type T2<T> = T extends number ? T[] : 'no'; // 제네릭 T는 naked 타입이라 분산이 된다.
type T3<T> = T[] extends number ? 'yes' : T[]; // 제네릭이지만 T[] 와 같이 변형된 타입 파라미터는 naked 타입이 아니라서 분산이 일어나지 않는다.

type T4 = T1; // "yes"
type T5 = T2<1 | 3 | 5 | 7>; // 1[] | 3[] | 5[] | 7[]
type T6 = T2<1 | 3 | 5 | 7>; // (1 | 3 | 5 | 7)[]
```

### 분산조건문에서 never

```ts
type Never<T> = T extends number ? T : never;

type Types = number | string | object;
type T2 = Never<Types>; // type T2 = number
```

never 타입은 에러나 예외 등을 처리하는데 사용되는 타입이다. "정상적이지 않은 값" 을 의미한다. 분산 조건부 분산이 일어나지 않는다. 위 예제에선 `number | never | never` 가 될 것으로 예상했지만, 실제론 `number` 타입만 가진다.

이를 이용해 다음과 같이,
 - 두 타입 인자를 받아 해당하는 타입을 제외시키는 Exclude 조건부 타입과
 - 두 타입 인자를 받아 해당하는 타입만 모아 반환 시키는 Extract 조건부 타입을 다음과 같이 구현 할 수 있다.
둘의 차이점은 never 위치가 앞뒤인 점 밖에 없다.

```ts
// 유니온 타입을 받아 T와 U를 비교해 U와 겹치는 타입들은 제외한 T를 반환하는 타입
type My_Exclude<T, U> = T extends U ? never : T;

type T2 = My_Exclude<1 | 3 | 5 | 7, 1 | 5 | 9>; // U 제네릭(1 | 5 | 9)에 속해있지 않은 3 | 7 만 반환됨
type T3 = My_Exclude<string | number | (() => void), Function>; // U 제네릭(Function)에 속해있지 않은 string | number 만 반환 됨

export {};
```

```ts
// 유니온 타입을 받아 T와 U를 비교해 U와 겹치는 타입들만 재구성해 T를 반환하는 타입
type My_Extract<T, U> = T extends U ? T : never;

type T4 = My_Extract<1 | 3 | 5 | 7, 1 | 5 | 9>; // U 제네릭에(1 | 5 | 9) 속해있는 1 | 5 만 반환됨

export {};
```

#### References

-
